use dropset_interface::{
    instructions::{
        generated_client::*,
        CloseSeatInstructionData,
        DepositInstructionData,
        RegisterMarketInstructionData,
        WithdrawInstructionData,
    },
    state::SYSTEM_PROGRAM_ID,
};
use solana_client::rpc_client::RpcClient;
use solana_instruction::Instruction;
use solana_sdk::pubkey::Pubkey;

use crate::{
    context::token::TokenContext,
    pda::find_market_address,
    views::{
        view_market_account,
        MarketSeatView,
        MarketView,
    },
};

pub struct MarketContext {
    pub market: Pubkey,
    pub base: TokenContext,
    pub quote: TokenContext,
    pub base_market_ata: Pubkey,
    pub quote_market_ata: Pubkey,
}

impl MarketContext {
    /// Creates a market with random tokens generated by airdropping funds.
    pub async fn new_market(rpc: &RpcClient) -> anyhow::Result<Self> {
        let base = TokenContext::new_token(rpc, None).await?;
        let quote = TokenContext::new_token(rpc, None).await?;
        let (market_address, _bump) = find_market_address(&base.mint, &quote.mint);
        let base_market_ata = base.get_ata_for(&market_address);
        let quote_market_ata = quote.get_ata_for(&market_address);
        Ok(Self {
            market: market_address,
            base,
            quote,
            base_market_ata,
            quote_market_ata,
        })
    }

    pub fn get_base_ata(&self, owner: &Pubkey) -> Pubkey {
        self.base.get_ata_for(owner)
    }

    pub fn get_quote_ata(&self, owner: &Pubkey) -> Pubkey {
        self.quote.get_ata_for(owner)
    }

    pub fn close_seat(&self, user: Pubkey, data: CloseSeatInstructionData) -> Instruction {
        CloseSeat {
            user,
            market_account: self.market,
            base_user_ata: self.get_base_ata(&user),
            quote_user_ata: self.get_quote_ata(&user),
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
        }
        .create_instruction(data)
    }

    pub fn deposit_base(&self, user: Pubkey, data: DepositInstructionData) -> Instruction {
        self.deposit(user, data, true)
    }

    pub fn deposit_quote(&self, user: Pubkey, data: DepositInstructionData) -> Instruction {
        self.deposit(user, data, false)
    }

    fn deposit(&self, user: Pubkey, data: DepositInstructionData, is_base: bool) -> Instruction {
        match is_base {
            true => Deposit {
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
            },
            false => Deposit {
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
            },
        }
        .create_instruction(data)
    }

    pub fn withdraw_base(&self, user: Pubkey, data: WithdrawInstructionData) -> Instruction {
        self.withdraw(user, data, true)
    }

    pub fn withdraw_quote(&self, user: Pubkey, data: WithdrawInstructionData) -> Instruction {
        self.withdraw(user, data, false)
    }

    fn withdraw(&self, user: Pubkey, data: WithdrawInstructionData, is_base: bool) -> Instruction {
        match is_base {
            true => Withdraw {
                user,
                market_account: self.market,
                user_ata: self.get_base_ata(&user),
                market_ata: self.base_market_ata,
                mint: self.base.mint,
                token_program: self.base.token_program,
            },
            false => Withdraw {
                user,
                market_account: self.market,
                user_ata: self.get_quote_ata(&user),
                market_ata: self.quote_market_ata,
                mint: self.quote.mint,
                token_program: self.quote.token_program,
            },
        }
        .create_instruction(data)
    }

    pub fn register_market(
        &self,
        payer: Pubkey,
        data: RegisterMarketInstructionData,
    ) -> Instruction {
        RegisterMarket {
            user: payer,
            market_account: self.market,
            base_market_ata: self.base_market_ata,
            quote_market_ata: self.quote_market_ata,
            base_mint: self.base.mint,
            quote_mint: self.quote.mint,
            base_token_program: self.base.token_program,
            quote_token_program: self.quote.token_program,
            ata_program: spl_associated_token_account_interface::program::ID,
            system_program: SYSTEM_PROGRAM_ID.into(),
        }
        .create_instruction(data)
    }

    pub fn view_market(&self, rpc: &RpcClient) -> anyhow::Result<MarketView<MarketSeatView>> {
        view_market_account(rpc, &self.market)
    }

    pub fn find_seat(
        &self,
        rpc: &RpcClient,
        user: &Pubkey,
    ) -> anyhow::Result<Option<MarketSeatView>> {
        let market = self.view_market(rpc)?;
        Ok(market.sectors.into_iter().find(|seat| &seat.user == user))
    }
}
